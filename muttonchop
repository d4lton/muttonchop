#!/usr/bin/env node

// =================================================================================================
//
// MuttonChop v2.0.0
// Nanigans, Inc.
// Copyright Â©2018, All Rights Reserved
//
// =================================================================================================

const fs = require('fs');
const meow = require('meow');
const http = require('http');
const url = require("url");
const syncrequest = require('sync-request');

const version = '2.0.0';

var daemonOptions = {
  outFile: 'server.out',
  errFile: 'server.err',
  max: 3
};

//
// Get command-line input:
//

function usage(exit) {
  const usage = 'usage: $ muttonchop [--webroot <directory-name>] [--port <port>] [--index <index-file-path>] [--datafile <data-file-path>] [--output <html-output-path>]';
  if (exit) {
    console.log(usage);
    process.exit(1);
  } else {
    return usage;
  }
}

const cli = meow(usage(), {
  flags: {
    webroot: {
      type: 'string',
      default: 'webroot'
    },
    output: {
      type: 'string',
      default: 'output'
    },
    port: {
      type: 'string',
      default: '8080'
    },
    index: {
      type: 'string',
      default: 'index.template'
    },
    datafile: {
      type: 'string'
    }
  }
});

if (!cli.flags.webroot) { usage(true); }

const port = parseInt(cli.flags.port);
const serverUrl = 'http://localhost:' + port;

function sendResponse(response, code, message) {
  response.writeHead(code);
  response.write(message);
  response.end();
}

function getDottedKeyValue(key, data) {
  var keyParts = key.split('.');
  var object = data;
  keyParts.forEach(function(keyPart) {
    if (object) { object = object[keyPart]; }
  });
  return object;
}

function getDataValue(key, data, context) {
  var value = getDottedKeyValue(key, data);
  if (context.prefix) {
    var prefixedValue = getDottedKeyValue(context.prefix + '.' + key, data);
    if (prefixedValue) { value = prefixedValue; }
  }
  return value;
}

function execute(code, data, context) {
  context = context || {};
  var params = code.split(' ').map(function(param) {return param.trim()}).filter(function(param) {return param !== ''});
  if (params.length > 0) {
    var command = params.shift();
    switch (command) {
      case 'import': // import <path> [<data-key-prefix>]
        var pathname = params.shift();
        context.prefix = undefined;
        if (params.length > 0) { context.prefix = params.shift(); }
        return parseTemplate(pathname, data, context);
        break;
      case 'loop': // loop <path> <loop-variable> <data-array-key> [<data-key-prefix>]
        var pathname = params.shift();
        var loopVariable = params.shift();
        var dataArrayKey = params.shift();
        context.prefix = undefined;
        if (params.length > 0) { context.prefix = params.shift(); }
        var dataArray = getDataValue(dataArrayKey, data, context);
        if (Array.isArray(dataArray)) {
          return dataArray.filter(function(it) {return it;}).map(function(dataElement) {
            data[loopVariable] = dataElement;
            return parseTemplate(pathname, data, context);
          }).join('');
        }
        break;
      default:
        return getDataValue(command, data, context);
        break;
    }
  }
  return '';
}

function getTokenMatches(template) {
  var match = null, matches = [], regex = /<<([\s\S]+?)>>/mig;
  while ((match = regex.exec(template)) !== null) { matches.push(match); }
  return matches;
}

function getMustacheMatches(template) {
  var match = null, matches = [], regex = /{{([\s\S]+?)}}/mig;
  while ((match = regex.exec(template)) !== null) {
    var parts = match[1].split(' ').map(function(it) {return it.trim().replace(/\"/g, '');});
    matches.push({
      token: match[0],
      parts: parts
    });
  }
  return matches;
}

function retrieveItems(metadata) {
  metadata.item_data = {};
  for (var i = 0; i < metadata.items; i++) {
    var itemId = 'item' + (i + 1);
    var skuIndex = Math.floor(Math.random() * metadata.item_set.length);
    var sku = metadata.item_set[skuIndex];
    var url = 'http://lxprtsapi01.nanigans.com:8080/product-feed/sku?app_id=' + metadata.app_id + '&feed_id=' + metadata.feed_id + '&sku=' + sku;
    var response = syncrequest('GET', url);
    var json = response.body.toString();
    if (json) {
      metadata.item_data[itemId] = JSON.parse(json);
    }
  }
}

function extractMetadata(template, data) {
  data.metadata = null;
  var regex = /<!--([\s\S]+?)-->/mig;
  match = regex.exec(template);
  if (match) {
    template = template.replace(match[0], '');
    data.metadata = JSON.parse(match[1].trim());
    retrieveItems(data.metadata);
  }
  return template;
}

function parseTemplate(pathname, data, context) {
  try {

    var template = fs.readFileSync(cli.flags.webroot + '/' + pathname).toString();
    template = extractMetadata(template, data);
    var matches = getTokenMatches(template);
    matches.forEach(function(match) {
      template = template.replace(match[0], execute(match[1], data, context));
    });
    if (data.metadata) {
      matches = getMustacheMatches(template);
      matches.forEach(function(match) {
        // if the mustache token is something like {{ "IMAGE" "item1" "image_link" }} and we have data for item1, do replacement
        if (match.parts.length > 2) {
          var itemId = match.parts[1];
          var columnId = match.parts[2];
          var itemData = data.metadata.item_data[itemId];
          if (itemData && itemData.data) {
            replacement = itemData.data.columns[columnId][0];
            template = template.replace(match.token, replacement);
          }
        }
      });
    }
    return template;

  } catch (error) {
    console.log(error.toString());
  }
}

function getData(data) {
  var data = data || {};
  if (cli.flags.datafile) {
    try {
      var json = fs.readFileSync(cli.flags.datafile);
      data = Object.assign(data, JSON.parse(json));
    } catch (error) {
      console.log(error);
    }
  }
  return data;
}

function constructHtmlFromTemplate(pathname, data) {
  return parseTemplate(pathname, getData(data));
}

function sendIndex(request, response) {
  try {
    fs.readdir(cli.flags.webroot, function(error, items) {
      if (error) {
        sendResponse(response, 500, error.toString());
      } else {
        var templates = items.map(function(item) {
          if (item !== cli.flags.index && item.indexOf('.template') !== -1) { return {pathname: item}; }
        });
        var html = constructHtmlFromTemplate(cli.flags.index, {templates: templates});
        sendResponse(response, 200, html);
      }
    });
  } catch (error) {
    console.log(error);
    sendResponse(response, 404, error.message);
  }
}

function sendHtml(request, response, pathname) {
  // build HTML from pathname as the main template
  var html = constructHtmlFromTemplate(pathname);
  if (html) {
    pathname = pathname.replace('.template', '.html');
    fs.writeFileSync(cli.flags.output + '/' + pathname, html);
    sendResponse(response, 200, html);
  } else {
    sendResponse(response, 404, 'Not Found');
  }
}

//
// Start HTTP server
//

console.log('MuttonChop v' + version + ' started.');
console.log('  URL: ' + serverUrl);
console.log('  webroot: ' + cli.flags.webroot);

http.createServer(function(request, response) {

  var pathname = url.parse(request.url).pathname;

  if (pathname === '/') {
    sendIndex(request, response);
  } else if (pathname.indexOf('..') !== -1) {
    sendResponse(response, 400, 'Not Found');
  } else {
    sendHtml(request, response, pathname);
  }

}).listen(port);
