#!/usr/bin/env node

// =================================================================================================
//
// MuttonChop v2.0.0
// Nanigans, Inc.
// Copyright Â©2018, All Rights Reserved
//
// =================================================================================================

const fs = require('fs');
const meow = require('meow');
const http = require('http');
const url = require("url");

const version = '2.0.0';

var daemonOptions = {
  outFile: 'server.out',
  errFile: 'server.err',
  max: 3
};

//
// Get command-line input:
//

function usage(exit) {
  const usage = 'usage: $ muttonchop [--webroot <directory-name>] [--port <port>] [--index <index-file-path>] [--datafile <data-file-path>]';
  if (exit) {
    console.log(usage);
    process.exit(1);
  } else {
    return usage;
  }
}

const cli = meow(usage(), {
  flags: {
    webroot: {
      type: 'string',
      default: 'webroot'
    },
    output: {
      type: 'string',
      default: 'output'
    },
    port: {
      type: 'string',
      default: '8080'
    },
    index: {
      type: 'string',
      default: 'index.template'
    },
    datafile: {
      type: 'string'
    }
  }
});

if (!cli.flags.webroot) { usage(true); }

const port = parseInt(cli.flags.port);
const serverUrl = 'http://localhost:' + port;

function sendResponse(response, code, message) {
  response.writeHead(code);
  response.write(message);
  response.end();
}

function getDottedKeyValue(key, data) {
  var keyParts = key.split('.');
  var object = data;
  keyParts.forEach(function(keyPart) {
    if (object) { object = object[keyPart]; }
  });
  return object;
}

function getDataValue(key, data, context) {
  var value = getDottedKeyValue(key, data);
  if (context.prefix) {
    var prefixedValue = getDottedKeyValue(context.prefix + '.' + key, data);
    if (prefixedValue) { value = prefixedValue; }
  }
  return value;
}

function execute(code, data, context) {
  context = context || {};
  var params = code.split(' ').map(function(param) {return param.trim()}).filter(function(param) {return param !== ''});
  if (params.length > 0) {
    var command = params.shift();
    switch (command) {
      case 'import': // import <path> [<data-key-prefix>]
        var pathname = params.shift();
        context.prefix = undefined;
        if (params.length > 0) { context.prefix = params.shift(); }
        return parseTemplate(pathname, data, context);
        break;
      case 'loop': // loop <path> <loop-variable> <data-array-key> [<data-key-prefix>]
        var pathname = params.shift();
        var loopVariable = params.shift();
        var dataArrayKey = params.shift();
        context.prefix = undefined;
        if (params.length > 0) { context.prefix = params.shift(); }
        var dataArray = getDataValue(dataArrayKey, data, context);
        if (Array.isArray(dataArray)) {
          return dataArray.filter(function(it) {return it;}).map(function(dataElement) {
            data[loopVariable] = dataElement;
            return parseTemplate(pathname, data, context);
          }).join('');
        }
        break;
      default:
        return getDataValue(command, data, context);
        break;
    }
  }
  return '';
}

function getTokenMatches(template) {
  var matches = [];
  var regex = /<<(.+?)>>/ig;
  var match;
  while ((match = regex.exec(template)) !== null) { matches.push(match); }
  return matches;
}

function parseTemplate(pathname, data, context) {
  try {
    var template = fs.readFileSync(cli.flags.webroot + '/' + pathname).toString(); //.split('\n').join('');
    var matches = getTokenMatches(template);
    matches.forEach(function(match) {
      template = template.replace(match[0], execute(match[1], data, context));
    });
    return template;
  } catch (error) {
    console.log(error.toString());
  }
}

function getData(data) {
  var data = data || {};
  if (cli.flags.datafile) {
    try {
      var json = fs.readFileSync(cli.flags.datafile);
      data = Object.assign(data, JSON.parse(json));
    } catch (error) {
      console.log(error);
    }
  }
  return data;
}

function constructHtmlFromTemplate(pathname, data) {
  return parseTemplate(pathname, getData(data));
}

function sendIndex(request, response) {
  try {
    fs.readdir(cli.flags.webroot, function(error, items) {
      if (error) {
        sendResponse(response, 500, error.toString());
      } else {
        var templates = items.map(function(item) {
          if (item !== cli.flags.index && item.indexOf('.template') !== -1) { return {pathname: item}; }
        });
        var html = constructHtmlFromTemplate(cli.flags.index, {templates: templates});
        sendResponse(response, 200, html);
      }
    });
  } catch (error) {
    console.log(error);
    sendResponse(response, 404, error.message);
  }
}

function sendHtml(request, response, pathname) {
  // build HTML from pathname as the main template
  var html = constructHtmlFromTemplate(pathname);
  if (html) {
    pathname = pathname.replace('.template', '.html');
    fs.writeFileSync(cli.flags.output + '/' + pathname, html);
    sendResponse(response, 200, html);
  } else {
    sendResponse(response, 404, 'Not Found');
  }
}

//
// Start HTTP server
//

console.log('MuttonChop v' + version + ' started.');
console.log('  URL: ' + serverUrl);
console.log('  webroot: ' + cli.flags.webroot);

http.createServer(function(request, response) {

  var pathname = url.parse(request.url).pathname;

  if (pathname === '/') {
    sendIndex(request, response);
  } else if (pathname.indexOf('..') !== -1) {
    sendResponse(response, 400, 'Not Found');
  } else {
    sendHtml(request, response, pathname);
  }

}).listen(port);
